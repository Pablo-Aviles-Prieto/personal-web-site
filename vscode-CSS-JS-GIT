                                // SHORTCUTS //
ctrl + s = guardar
ctrl + space = auto completar
alt + shift + f = darle formato
ctrl + ñ = abrir consola
ctrl + k + c = comenta/descomenta la línea seleccionada
ctrl + ç = comenta/descomenta la línea seleccionada
alt + flecha arriba/abajo = mueve el bloque seleccionado o línea arriba o abajo
shift + alt + w = Permite crear etiquetas por abreviación a un conjunto de texto


// PATHS //
File => preference => extensions = para checkear/descargar extensiones
View => explorer = volver a vista explorador
File => preference => settings (buscar formatter) = para cambiar el formateador default


// MISCELLANEOUS //
Apuntes Sara: https://www.notion.so/FOAP-2022-09a2f0d31fee4f32a47b276f16068e43


// CSS //
Margin collapsing:  1- Solo ocurre entre elementos adyacentes
                    2- Solo afecta margenes verticales
                    3- El margen más grande, es el que predomina

Centrar objetos:    1-  Block elements (que ocupan todo el ancho), solo puede alinearse
                        con un margin poniendo el valor auto.
                    2-  In-line elements (no tienen top y bottom margins), se alinean
                        con un text-align sobre un elemento que los contenga (padre).





                                   // JS TIPS //

Jugar con el resto/reminder para cortar arrays según un número dado: 
                                (a % size !== size - 1)
Mirando este ejemplo:       

                        function chunkArrayInGroups(arr, size) {
                            for (let a = 0; a < arr.length; a++) {
                                 if (a % size !== size - 1) --> esto es un ! = = junto.

                        chunkArrayInGroups([0, 1, 2, 3, 4, 5, 6, 7, 8], 4)

Hace una iteración por los elementos de una array que se entrega y nos dan a mayores un número (size) que es por donde vamos a cortar la array y dividirla en otras arrays.
En este caso, la condición es que la iteración de 'a' (0, 1, 2...) se divida entre el size (4 en este ejemplo de arriba) y el operador % (reminder) dara el resto de dicha división (de ahí que un nº dividido entre 2 y el resto sea 0, es par --> val % 2 === 0)

Pues con una iteración de búcle diviéndola entre el número de veces que queremos cortar la array (size en el ejemplo), el resto siempre va ser igual a (size - 1) cuando la iteración, es decir 'a', llegue a (size - 1).
En el ejemplo, el resto siempre dará 1, cuando 'a' sea, 3, 7, 11, 15 (aumenta por 4, que es el size), ya que es justamente múltiplos del size (4) restándole 1 y por lo tanto el resto siempre va ser el múltiplo (size) - 1 unidad, de ahí que en la equivalencia estricta, se reste 1.



                                 // GIT COMMANDS & THEORY //
- Working area = Es la carpeta del proyecto donde se está trabajando (imagenes/archivos/carpetas...)
        REPOSITORY (DONDE SE ALMACENAN BKUPS / EN EL REPOSITORIO ENGLOBA COMMIT Y BRANCHES)
- Commits = Es una snapshot de tu código en un momento específico. (Un cambio de código, como añadir una imagen, fixear una botonera...)
- Branches = Se usa para almacenar los commits y siempre se updatea y apunta al último introducido. Sirve para poder revisar el historial de cambios/commits. (Generalmente se llama master/main branch).
Por ejemplo cuando haces un trabajo específico puedes crear una branch en específico para trackear solo ese progreso (como crear una página nueva) y una vez esté finalizada, meter esa branch creada en la master para tener todo el historial de snapshots juntas.

- ELIMINAR EL PERSONAL ACCESS TOKEN DE VSCODE STORED ON THE MACHINE
  git credential reject => ENTER
  host=github.com => ENTER
  protocol=https => ENTER


git --version --> Indica la versión instalada de git (verificar installation).

git init --> Sirve para "iniciar" el proyecto de git (estando en la carpeta que quieres usar).

git status --> Vemos información sobre el proyecto de git actual.

git log --> Nos da una visión general de todos los commits dentro del master branch.

git add . (git commit -m "msg") --> Sirve para añadir todos los archivos no trackeados a la      staging area (similar al git add) y a mayores sirve para añadir todos los cambios que se hicieron a los archivos ya trackeados de la staging area.
TRAS ujsar git add . / podemos usar en otra línea un git commit -m "message" para añadir el mensaje al commit que vamos a lanzar.

git add filename --> Añadimos el archivo indicado para que sea trackeado y sea parte del próximo snapshot. Con esto lo añadimos a la staging area (que significa que ese archivo esta en espera de que se añada como commit y a los snapshots).

git commit -m "message"--> Añade un mensaje al commit que se realizará para indicar que cambios se hicieron sobre el código
La primera vez añade este mensaje para que así quien suba commits/snapshots esté identificado.

Author identity unknown
*** Please tell me who you are.
Run
  git config --global user.email "you@example.com"
  git config --global user.name "Your Name"


git config --global --edit --> Sirve para ver/editar el archivo de configuración con el usuario y email.

Escape - escribir :x --> sirve para salir del editor en unix.
git config --global user.name --> indica el nombre de usuario de git.
git config --global user.name "nombre" --> Añade de nombre de usuario el que escribamos.
git config --global user.mail "mail" --> Añade el mail indicado entre comillas al usuario de git

git branch --> Muestra cuantos branches hay.

git branch -m NOMBRE --> Cambia el nombre del branch QUE ESTEMOS DENTRO.

git checkout --> Sirve para moverse entre diferentes branches.

git checkout -b NOMBRE --> Sirve para crear un nuevo branch basado (-b) en el branch en el que estamos, si lo creamos desde el main/master nos lo creará "linkeado" a dicho branch.

MERGING funciona de manera que estoy ahora mismo dentro de un branch que debería recibir commits adicionales.
Por ejemplo si queremos añadir un branch 'feature' (creado sobre el main branch) sobre el master/main branch, hay que cambiarse a la branch main/master y luego hacer un merge (unir) del feature al master branch.

git merge NOMBRE --> Nos referimos al branch que contiene los commits que queremos añadir a la main (o cualquier otra) branch.

git rm PATH/ARCHIVO --> Borra el archivo indicado

git reset --hard HEAD~1 --> Borra el último commit y vuelve la cabecera (HEAD) 1 paso hacia atrás.

git branch -D NOMBRE_BRANCH --> Borra el branch indicado sin estar en directorio/path.

git checkout -- . --> Con este comando, reseteamos el branch al estado del último commit.

git restore --staged <file> --> Sirve para quitar un archivo indicado de la staging area para que no se comite en el próximo commit. A mayores luego haces un git checkout -- file1.txt (o el nombre del archivo que quieras quitar definitivamente del stage) para eliminar esa modificación.

git restore <file> --> Sirve para quitar un archivo que no está en la staging area, para diferenciarlo del staged, por si acaso quieres volver a un momento del archivo anterior que n ofue comiteado, pero si añadido a la staging area.

git reset PATH/FILE --> Sirve para cuando tienes archivos en el staging area y decides no comitearlos, los quitas del staging area y luego haces un git checkout -- file1.txt (o el nombre del archivo que quieras quitar definitivamente del stage) para eliminar esa modificación.


                                 // GITHUB COMMANDS //

FORK = permite copiar un repositorio a nuestra propia cuenta de github (dicho repositorio copiado no tiene relación con el original, sería 'nuestro').


git remote add origin LINK-TO-GITHUB --> Añade una conexión remota a un repositorio que indicamos.
El origin sirve para vincular ese nombre a dicho enlace (se podría cambiar el origin). Así en futuros comandos se puede referir a dicho link con la palabra indicada (en este caso origin).

git push -u origin main --> Pushearía/Enviaría el branch main del git(local) en el que estamos, al enlace que está asociado en este caso, 'origin'.

git clone LINK . --> Nos clona un repositorio de github en la carpeta en la que estemos en CMD. El punto final después del enlace copia el contenido directamente a la carpeta en la que estamos, sin crear una subcarpeta.

git pull --> Sirve para actualizar el git/repositorio local del repositorio de github/remoto.
